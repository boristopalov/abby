"""SQLite FTS5-backed search index for the Ableton Live Python API docs.

The source is ~/.abby/live-docs.xml — an unofficial API reference generated by
decompiling Ableton's .pyc bytecode. The index is stored at ~/.abby/live-docs.db
and is rebuilt automatically whenever the XML file is newer than the last build.
"""

import re
import sqlite3
import xml.etree.ElementTree as ET
from pathlib import Path

from .logger import logger

LIVE_DOCS_XML = Path.home() / ".abby" / "live-docs.xml"
LIVE_DOCS_DB = Path.home() / ".abby" / "live-docs.db"

_conn: sqlite3.Connection | None = None


def _parse_xml() -> list[tuple[str, str, str]]:
    """Parse live-docs.xml into a flat list of (tag, name, doc) triples."""
    tree = ET.parse(LIVE_DOCS_XML)
    children = list(tree.getroot())
    entries: list[tuple[str, str, str]] = []
    for i, elem in enumerate(children):
        if elem.tag == "Doc":
            continue
        name = (elem.text or "").strip()
        if not name:
            continue
        doc = ""
        if i + 1 < len(children) and children[i + 1].tag == "Doc":
            doc = (children[i + 1].text or "").strip()
        entries.append((elem.tag, name, doc))
    return entries


def _build_index(conn: sqlite3.Connection) -> None:
    logger.info("[live_docs] Building FTS5 index from %s", LIVE_DOCS_XML)
    conn.execute("DROP TABLE IF EXISTS api_docs")
    conn.execute("""
        CREATE VIRTUAL TABLE api_docs USING fts5(
            tag, name, doc,
            tokenize='porter ascii'
        )
    """)
    conn.execute("CREATE TABLE IF NOT EXISTS _meta (key TEXT PRIMARY KEY, value TEXT)")
    entries = _parse_xml()
    conn.executemany("INSERT INTO api_docs VALUES (?, ?, ?)", entries)
    xml_mtime = str(LIVE_DOCS_XML.stat().st_mtime)
    conn.execute("INSERT OR REPLACE INTO _meta VALUES ('xml_mtime', ?)", (xml_mtime,))
    conn.commit()
    logger.info("[live_docs] Indexed %d entries", len(entries))


def _open_conn() -> sqlite3.Connection:
    LIVE_DOCS_DB.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(LIVE_DOCS_DB, check_same_thread=False)

    xml_mtime = LIVE_DOCS_XML.stat().st_mtime
    try:
        row = conn.execute(
            "SELECT value FROM _meta WHERE key='xml_mtime'"
        ).fetchone()
        if row and float(row[0]) >= xml_mtime:
            logger.info("[live_docs] FTS5 index is up to date")
            return conn
    except sqlite3.OperationalError:
        pass  # _meta table doesn't exist yet

    _build_index(conn)
    return conn


def _get_conn() -> sqlite3.Connection:
    global _conn
    if _conn is None:
        _conn = _open_conn()
    return _conn


def _fts_query(query: str) -> str:
    """Convert a query into an FTS5-safe expression.

    Splits on any non-word character (including dots, which FTS5 rejects as
    syntax errors). Each token becomes an independent AND term.
    """
    tokens = re.findall(r"\w+", query)
    return " ".join(tokens)


def search(query: str, limit: int = 8) -> str:
    """Search the Live API docs and return a formatted result string."""
    if not LIVE_DOCS_XML.exists():
        return (
            "Live API docs not found. "
            f"Expected XML at {LIVE_DOCS_XML}. "
            "Generate it by running the API_MakeDoc MIDI Remote Script inside Ableton."
        )

    fts = _fts_query(query)
    if not fts:
        return "Empty query."

    try:
        rows = _get_conn().execute(
            "SELECT tag, name, doc FROM api_docs WHERE api_docs MATCH ? ORDER BY rank LIMIT ?",
            (fts, limit),
        ).fetchall()
    except sqlite3.OperationalError as e:
        logger.error("[live_docs] Search error: %s", e)
        return f"Search error: {e}"

    if not rows:
        return f"No results for '{query}'."

    lines: list[str] = []
    for i, (tag, name, doc) in enumerate(rows, 1):
        lines.append(f"[{i}] {tag}: {name}")
        if doc:
            # Trim very long doc strings to keep context usage reasonable
            trimmed = doc if len(doc) <= 300 else doc[:300] + "…"
            lines.append(f"    {trimmed}")
    return "\n".join(lines)
